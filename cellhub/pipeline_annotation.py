"""
===================
Pipeline annotation
===================

Overview
========

This pipeline retrieves annotation from Ensembl

Usage
=====

The annotation pipeline should be run in the cellhub directory.

Configuration
-------------

The pipeline requires a configured :file:`pipeline_cluster.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_annotation.py config
   
The ensembl version specified in the yaml file should match that used to
build the reference transcriptome for the mapping algorithm (e.g. Cellranger)

Inputs
------

This pipeline has no inputs.

Dependencies
------------

This pipeline requires:


Pipeline output
===============

The pipeline produces the following outputs:

1. api/annotation/ensembl/ensembl.to.entrez.tsv.gz

- A mapping of ensembl_id to gene_name and entrez_id. Used by gsfisher for
  pathway analysis.

2. api/annotation/ensembl/ensembl.gene_name.map.tsv.gz

- A unique mapping of ensembl_id -> gene_name. Missing gene names are
  replaced with ensembl_ids. The gene names have been made unique.

3. api/annotation/kegg/kegg_pathways.rds

- Kegg pathways in rds format for gsfisher.

"""

import os
import sys
import gzip
from shutil import copyfile

from pathlib import Path
import pandas as pd
from ruffus import *
from cgatcore import pipeline as P
import cgatcore.iotools as IOTools

import cellhub.tasks as T

# -------------------------- Pipeline Configuration -------------------------- #

# Override function to collect config files
P.control.write_config_files = T.write_config_files

# load options from the yml file
P.parameters.HAVE_INITIALIZED = False
PARAMS = P.get_parameters(T.get_parameter_file(__file__))

# set the location of the code directory
PARAMS["cellhub_code_dir"] = Path(__file__).parents[1]

# ------------------------------ Pipeline Tasks ------------------------------ #


# ########################################################################### #
# #################### Retrieve geneset annoations ########################## #
# ########################################################################### #

@files(None,
       "annotation.dir/ensembl.to.entrez.sentinel")
def fetchEnsembl(infile, outfile):
    '''
       Fetch the ensembl annotations from BioMart. This task requires internet 
       access.
    '''

    spec, SPEC = T.get_vars(infile, outfile, PARAMS,
                               make_outdir = False)

    if PARAMS["annotation_ensembl_host"] == "default":
        ensembl_host = ""
    else:
        ensembl_host = "--ensemblhost=%(annotation_ensembl_host)s" % PARAMS

    if not os.path.exists(spec.outdir):
        os.mkdir(spec.outdir)

    # Some clusters do not support internet access from execution nodes
    to_cluster = False

    statement = '''Rscript %(cellhub_code_dir)s/R/scripts/annotation_fetch_ensembl.R
                    --ensemblversion=%(annotation_ensembl_release)s
                    %(ensembl_host)s
                    --species=%(annotation_species)s
                    --outdir=%(outdir)s
                    &> %(log_file)s
                ''' % dict(PARAMS, **SPEC, **locals())

    P.run(statement)

    IOTools.touch_file(outfile)


@files(fetchEnsembl,
       "annotation.dir/ensembl.api.sentinel")
def ensemblAPI(infile, outfile):
    '''
        Add the Ensembl gene annotation results to the cellhub API.
    '''

    file_set={"anno": {"path": "annotation.dir/ensembl.to.entrez.tsv.gz",
                               "description":"mapping of ensembl to entrez ids",
                               "format":"tsv"},
              
              "emap": {"path": "annotation.dir/ensembl.gene_name.map.tsv.gz",
                               "description":"mapping of ensembl ids to gene_name",
                               "format":"tsv"}
    }
    
    x = T.api("annotation")

    x.define_dataset(analysis_name="ensembl",
              file_set=file_set,
              analysis_description="Ensembl gene annotations")

    x.register_dataset()


@files(None,
       "annotation.dir/kegg.pathways.sentinel")
def fetchKegg(infile, outfile):
    '''
       Fetch the Kegg pathway annotations. This task requires internet access.
    '''

    spec, SPEC = T.get_vars(infile, outfile, PARAMS,
                               make_outdir = False)

    if not os.path.exists(spec.outdir):
        os.mkdir(spec.outdir)

    # Some clusters do not support internet access from execution nodes
    to_cluster = False

    outfile_name = outfile.replace(".sentinel", ".rds")

    statement = '''Rscript %(cellhub_code_dir)s/R/scripts/annotation_fetch_kegg.R
                    --species=%(annotation_species)s
                    --outfile=%(outfile_name)s
                    &> %(log_file)s
                ''' % dict(PARAMS, **SPEC, **locals())

    P.run(statement)
    IOTools.touch_file(outfile)


@files(fetchKegg,
       "annotation.dir/kegg.pathways.api.sentinel")
def keggAPI(infile, outfile):
    '''
       Add the kegg pathways to the cellhub API
    '''

    target_file = infile.replace(".sentinel", ".rds")

    file_set={"annotations" : {"path": target_file,
                               "description":"kegg pathway annotations",
                               "format":"tsv"}
    }

    x = T.api("annotation")

    x.define_dataset(analysis_name="kegg",
              file_set=file_set,
              analysis_description="kegg pathway annotations")

    x.register_dataset()


# ########################################################################### #
# ##################### full target: to run all tasks ####################### #
# ########################################################################### #


@follows(keggAPI, ensemblAPI)
def full():
    pass


# ------------------- < ***** end of pipeline **** > ------------------------ #

def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
