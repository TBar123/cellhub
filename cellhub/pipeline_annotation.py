"""=============
Pipeline annotation
================

Overview
========

This pipeline retrieves annotation from Ensembl

Usage
=====

It is recommended to run the annotation pipeline in the cellhub directory.

Configuration
-------------

The pipeline requires a configured :file:`pipeline_cluster.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_annotation.py config


Inputs
------

This pipeline has no inputs.

Dependencies
------------

This pipeline requires:


Pipeline output
===============

The pipeline produces the following outputs:


"""

import os
import sys
import gzip
from shutil import copyfile

from pathlib import Path
import pandas as pd
from ruffus import *
from cgatcore import pipeline as P
import cgatcore.iotools as IOTools

import cellhub.tasks.control as C
import cellhub.tasks.TASK as TASK
import cellhub.tasks.api as api

# Override function to collect config files
P.control.write_config_files = C.write_config_files


# -------------------------- < parse parameters > --------------------------- #

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline_annotation.yml" % os.path.splitext(__file__)[0],
     "../pipeline_annotation.yml",
     "pipeline_annotation.yml"])

# set the location of the code directory
PARAMS["cellhub_code_dir"] = Path(__file__).parents[1]


# ----------------------- < pipeline configuration > ------------------------ #

# handle pipeline configuration
if len(sys.argv) > 1:
        if(sys.argv[1] == "config") and __name__ == "__main__":
                    sys.exit(P.main(sys.argv))

# ------------------------------ < functions > ------------------------------ #


# ########################################################################### #
# #################### Retrieve geneset annoations ########################## #
# ########################################################################### #

# Retrieve gene annotations and KEGG pathways.
#
# The "ensembl.to.entrez.tsv.gz" table is needed for:
# - adding ensembl gene_ids to the findMarkers results table if s@misc$gene
#   is not set
# - translating ensembl gene_ids to entrez gene_ids for the geneset
#   analysis

@files(None,
       "annotation.dir/ensembl.to.entrez.sentinel")
def fetchEnsembl(infile, outfile):
    '''Get mappings between Ensembl gene_ids 
    '''

    spec, SPEC = TASK.get_vars(infile, outfile, PARAMS,
                               make_outdir = False)

    if PARAMS["annotation_ensembl_host"] == "default":
        ensembl_host = ""
    else:
        ensembl_host = "--ensemblhost=%(annotation_ensembl_host)s" % PARAMS

    # set the job threads and memory
    #job_threads, job_memory, r_memory = TASK.get_resources(
    #    memory=PARAMS["resources_memory_low"])

    if not os.path.exists(spec.outdir):
        os.mkdir(spec.outdir)

    # Some clusters do not support internet access from execution nodes
    to_cluster = False

    #outfile_name = outfile.replace(".sentinel", ".tsv.gz")

    statement = '''Rscript %(cellhub_code_dir)s/R/scripts/annotation_fetch_ensembl.R
                    --ensemblversion=%(annotation_ensembl_release)s
                    %(ensembl_host)s
                    --species=%(annotation_species)s
                    --outdir=%(outdir)s
                    &> %(log_file)s
                ''' % dict(PARAMS, **SPEC, **locals())

    P.run(statement)

    IOTools.touch_file(outfile)


@files(fetchEnsembl,
       "annotation.dir/ensembl.api.sentinel")
def ensemblAPI(infile, outfile):
    '''
    Add the ensembl gene annotation results to the API
    '''

    file_set={"anno": {"path": "annotation.dir/ensembl.to.entrez.tsv.gz",
                               "description":"mapping of ensembl to entrez ids",
                               "format":"tsv"},
              
              "emap": {"path": "annotation.dir/ensembl.gene_name.map.tsv.gz",
                               "description":"mapping of ensembl ids to gene_name",
                               "format":"tsv"}
    }
    
    x = api.api("annotation")

    x.define_dataset(analysis_name="ensembl",
              file_set=file_set,
              analysis_description="Ensembl gene annotations")

    x.register_dataset()


@files(None,
       "annotation.dir/kegg.pathways.sentinel")
def fetchKegg(infile, outfile):
    '''Get mappings between Ensembl gene_ids, gene symbols and entrez ids 
    '''

    spec, SPEC = TASK.get_vars(infile, outfile, PARAMS,
                               make_outdir = False)

    if not os.path.exists(spec.outdir):
        os.mkdir(spec.outdir)

    # Some clusters do not support internet access from execution nodes
    to_cluster = False

    outfile_name = outfile.replace(".sentinel", ".rds")

    statement = '''Rscript %(cellhub_code_dir)s/R/scripts/annotation_fetch_kegg.R
                    --species=%(annotation_species)s
                    --outfile=%(outfile_name)s
                    &> %(log_file)s
                ''' % dict(PARAMS, **SPEC, **locals())

    P.run(statement)
    IOTools.touch_file(outfile)


@files(fetchKegg,
       "annotation.dir/kegg.pathways.api.sentinel")
def keggAPI(infile, outfile):
    '''
    Add the kegg pathways to the API
    '''

    target_file = infile.replace(".sentinel", ".rds")

    file_set={"annotations" : {"path": target_file,
                               "description":"kegg pathway annotations",
                               "format":"tsv"}
    }

    x = api.api("annotation")

    x.define_dataset(analysis_name="kegg",
              file_set=file_set,
              analysis_description="kegg pathway annotations")

    x.register_dataset()

# ########################################################################### #
# ##################### full target: to run all tasks ####################### #
# ########################################################################### #


@follows(keggAPI, ensemblAPI)
def full():
    pass


# ------------------- < ***** end of pipeline **** > ------------------------ #


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
