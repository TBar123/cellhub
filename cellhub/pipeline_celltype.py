"""===========================
Pipeline celltype
===========================

Overview
========

This pipeline computes celltype assignment predictions. 

Currently singleR is supported.

Usage
=====

See :doc:`Installation</Installation>` and :doc:`Usage</Usage>` on general
information how to use CGAT pipelines.

Configuration
-------------

The celltyping pipeline is run in the cellhub directory.

The pipeline requires a configured :file:`pipeline_celltype.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_celltype.py config


Inputs
------

The pipeline starts from an anndata object with the following structure.

anndata.X = 
anndata.layers[""]
anndata.layers[""]


Dependencies
------------

This pipeline requires:


Pipeline output
===============

The pipeline produces the following outputs:


"""

import os
import sys
import gzip
from shutil import copyfile

from pathlib import Path
import pandas as pd
from ruffus import *
from cgatcore import pipeline as P
import cgatcore.iotools as IOTools

import cellhub.tasks.control as C
import cellhub.tasks.fetch_cells as fetch_cells

# Override function to collect config files
P.control.write_config_files = C.write_config_files


# -------------------------- < parse parameters > --------------------------- #

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline_celltype.yml" % os.path.splitext(__file__)[0],
     "../pipeline_celltype.yml",
     "pipeline_celltype.yml"])

# set the location of the code directory
PARAMS["cellhub_code_dir"] = Path(__file__).parents[1]


# ----------------------- < pipeline configuration > ------------------------ #

# handle pipeline configuration
if len(sys.argv) > 1:
        if(sys.argv[1] == "config") and __name__ == "__main__":
                    sys.exit(P.main(sys.argv))

# ------------------------------ < functions > ------------------------------ #


# ########################################################################### #
# ############################# pipeline tasks ############################## #
# ########################################################################### #

# ################################################################### #
# ############### Predict cell-types using singleR ################### #
# #################################################################### #

def genSingleRjobs():
    '''generate the singleR jobs'''

    seurat_objects = glob.glob("*.seurat.dir/begin.rds")

    references = [x.strip() for x in PARAMS["singleR_reference"].split(",")]

    for seurat_object in seurat_objects:

        seurat_dir = os.path.dirname(seurat_object)

        for reference in references:

            yield [seurat_object,
                   os.path.join(seurat_dir,
                                "singleR.dir",
                                reference + ".ref.dir",
                                "singleR.sentinel")]


@active_if(PARAMS["run_singleR"])
@follows(seuratPCA, headstart)
@files(genSingleRjobs)
def singleR(infile, outfile):
    '''Perform cell identity prediction on a saved seurat object.
    The reference dataset is chosen by the user.

    The output consists of an rds object containing the prediction
    result ("predictions.rds") and a tsv file containing the predicted
    labels ("labels.tsv.gz")
    '''

    reference = os.path.basename(
        Path(outfile).parents[0]).replace(".ref.dir","")


    if PARAMS["headstart_singleR"]:

        spec, SPEC = TASK.get_vars(infile, outfile, PARAMS,
                                   make_outdir=True)

        source = os.path.join(PARAMS["headstart_path"],
                                     spec.sample_dir,
                              "singleR.dir",
                              reference + ".ref.dir")

        if os.path.exists(source):

            source_files = glob.glob(os.path.join(source,
                                                      "*"))

            for sf in [x for x in source_files if not x.endswith("singleR.sentinel")]:

                if os.path.exists(sf):
                    os.symlink(sf,
                               os.path.join(spec.sample_dir,
                                            "singleR.dir",
                                            reference + ".ref.dir",
                                            os.path.basename(sf)))

                else:
                    raise ValueError("Headstart singleR path not found")

            IOTools.touch_file(outfile)

    else:

        spec, SPEC = TASK.get_vars(infile, outfile, PARAMS)


        # set the job threads and memory
        job_threads, job_memory, r_memory = TASK.get_resources(
            memory=PARAMS["resources_memory_extreme"],
            cpu=PARAMS["singleR_workers"])

        statement = '''Rscript %(tenx_dir)s/R/singleR_run.R
                           --seuratobject=%(infile)s
                           --reference=%(reference)s
                           --workers=%(singleR_workers)s
                           --outdir=%(outdir)s

                           &> %(log_file)s
                           ''' % dict(PARAMS, **SPEC, **locals())

        P.run(statement)
        IOTools.touch_file(outfile)


# ########################################################################### #
# ##################### full target: to run all tasks ####################### #
# ########################################################################### #


@follows()
def full():
    pass


# ------------------- < ***** end of pipeline **** > ------------------------ #


def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
