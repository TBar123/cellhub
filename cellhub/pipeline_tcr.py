'''
======================
pipeline_tcr.py
======================


Overview
========

The pipeline performs a series of tasks aimed at TCR analysis of single cell RNA sequencing data.

It performs the following functions:

* Identifies TCR chain and contigs in each TCR chain for each single cell
* Performs chain QC, in order to highlight multichain cells and to annotate cell types with specific, distinctive chain configurations
* (to be done) Performes clonotype analysis, that is it calculates diversity indices and lists enriched clonotypes
* (to be done) Performs clustering of CDR3 sequences, to identify clonal neighbours
* (to be done) Identifies whether for each TCR, a known antigenic specificity can be predicted

Usage
=====

See :doc:`Installation</Installation>` and :doc:`Usage</Usage>` for general
information on how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured:file:`pipeline_tcr.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_tcr.py config


Inputs
------

In addition to the "pipeline_tcr.yml" file, the pipeline requires two inputs: 

# api/cellranger/ .... tcr (vdj-t) ... 

Dependencies
------------

This pipeline requires:
* cgat-core: https://github.com/cgat-developers/cgat-core
* cellranger: https://support.10xgenomics.com/single-cell-gene-expression/


Pipeline logic
--------------

The pipeline is designed to perform TCR reconstruction 


Pipeline output
---------------

The pipeline returns:

* a tsv table that map the cell barcode to tcr-related statistics and annotations.



Code
====

'''

from ruffus import *
from pathlib import Path
import sys
import os
import glob
import sqlite3
import yaml
import csv

import cgatcore.experiment as E
from cgatcore import pipeline as P
import cgatcore.iotools as IOTools

import pandas as pd
import numpy as np

# import local pipeline utility functions
import cellhub.tasks as T
import cellhub.tasks.cellranger as cellranger
import cellhub.tasks.samples as samples

# -------------------------- Pipeline Configuration -------------------------- #

# Override function to collect config files
P.control.write_config_files = T.write_config_files

# load options from the yml file
P.parameters.HAVE_INITIALIZED = False
PARAMS = P.get_parameters(T.get_parameter_file(__file__))

# set the location of the code directory
PARAMS["cellhub_code_dir"] = Path(__file__).parents[1]


if len(sys.argv) > 1:
        if(sys.argv[1] == "config") and __name__ == "__main__":
                    sys.exit(P.main(sys.argv))


# ---------------------------- Pipeline tasks ------------------------------- #

# ########################################################################### #
# ###########################  TCR Analysis  ############################## #
# ########################################################################### #


# 1. recreation of basic stats ala COMBAT with e.g. scirpy or manual script (TCR QC)


@follows(mkdir("tcr.dir"))

@transform(glob.glob("cellranger.vdj.t.dir/*/outs/all_contig_annotations.csv"), 
regex(r".*/.*/(.*)/outs/all_contig_annotations.csv")


def construct_ir(infile, outfile):
    ''' 
    Create TCR chain table. 
    '''
    t = T.setup(infile, outfile, PARAMS,
                memory=PARAMS["cellranger_localmem"],
                cpu=PARAMS["cellranger_localcores"])

    #t.outdir == outdir = os.path.dirname(outfile)
    #t.resources == {"job_threads": cores; "job_memory": G}
    # inputs will be: a list of h5 from cellranger and a list of csv.gz from cellranger vdj
    # grabs the .obs, simplifies list, adds predicted cell identity
  

    statement = '''python %(cellhub_code_dir)s/python/tcr_scirpy.py
                   -- inputs?
                   -- outputs %(outdir)s
                    &> %(log_file)s
                 ''' % dict(PARAMS, 
                            **t.var, 
                            **locals())

    P.run(statement, **t.resources)
    IOTools.touch_file(outfile)

@follows(mkdir("tcr.dir"))




# ---------------------------< Pipeline targets >------------------------------ #

@follows(construct_it, chainQC)
@files(None, "diffcomp.dir/plot.sentinel")

# def plot(infile, outfile):
#     '''Draw the pipeline flowchart'''

#     pipeline_printout_graph("diffcomp.dir/pipeline_flowchart.svg",
#                           "svg",
#                           [full],
#                           no_key_legend=True)

#     pipeline_printout_graph("diffcomp.dir/pipeline_flowchart.png",
#                           "png",
#                           [full],
#                           no_key_legend=True)

#     IOTools.touch_file(outfile)


def full():
    '''
    Run the full pipeline.
    '''
    pass



def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))