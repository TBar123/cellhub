"""
===================
Pipeline Emptydrops
===================

Overview
========

This pipeline performs the following task:

* run emptydrops on the raw output of cellranger

Usage
=====

See :doc:`Installation</Installation>` and :doc:`Usage</Usage>` on general
information how to use CGAT pipelines.

Configuration
-------------

The pipeline requires a configured :file:`pipeline.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_emptydrops.py config


Input files
-----------

The pipeline is run from the cellranger count output (raw_feature_bc_matrix folder).

The pipeline expects a tsv file containing a column named path and a column named
sample_id.

'raw path' should contain the path to each cellranger path to raw_feature_bc_matrix.
'sample_id' is the desired name for each sample (output folder will be named like this).


Dependencies
------------

This pipeline requires:
* cgat-core: https://github.com/cgat-developers/cgat-core
* R + packages

Pipeline output
===============

The pipeline returns:
A list of barcodes passing emptydrops cell identification and a table with
barcode ranks including all barcodes (this can be used for knee plots).


Code
====

"""
from ruffus import *
from pathlib import Path
import sys
import os
import yaml
import cgatcore.experiment as E
from cgatcore import pipeline as P
import cgatcore.iotools as IOTools
import pandas as pd

import cellhub.tasks as T

# -------------------------- Pipeline Configuration -------------------------- #

# Override function to collect config files
P.control.write_config_files = T.write_config_files

# load options from the yml file
P.parameters.HAVE_INITIALIZED = False
PARAMS = P.get_parameters(T.get_parameter_file(__file__))

# set the location of the code directory
PARAMS["cellhub_code_dir"] = Path(__file__).parents[1]

# ------------------------------ Pipeline Tasks ------------------------------ #


@transform("api/cellranger.multi/counts/unfiltered/*/mtx/matrix.mtx.gz",
           regex(r".*/.*/counts/unfiltered/(.*)/mtx/matrix.mtx.gz"),
           r"emptydrops.dir/emptydrops.dir/\1/emptydrops.sentinel")
def emptyDrops(infile, outfile):
    ''' Run Rscript to run EmptyDrops on each library '''

    t = T.setup(infile, outfile, PARAMS,
                memory=PARAMS["emptydrops_memory"], 
                cpu=PARAMS["emptydrops_slots"])

    options = {}
    options["FDR"] = float(PARAMS["emptydrops_FDR"])
    options["outdir"] = t.outdir
    options["cellrangerDir"] = os.path.dirname(infile)

    task_yaml_file = os.path.abspath(os.path.join(t.outdir, "emptydrops.yml"))
    with open(task_yaml_file, 'w') as yaml_file:
        yaml.dump(options, yaml_file)
        
    log_file = t.log_file

    statement = '''Rscript %(cellhub_code_dir)s/R/scripts/emptydrops_run.R
                   --task_yml=%(task_yaml_file)s
                   --log_filename=%(log_file)s
                '''

    P.run(statement, **t.resources)

    IOTools.touch_file(outfile)


@transform("api/cellranger.multi/counts/unfiltered/*/mtx/matrix.mtx.gz",
           regex(r".*/.*/counts/unfiltered/(.*)/mtx/matrix.mtx.gz"),
           r"emptydrops.dir/meanreads.dir/\1/meanreads.sentinel")
def meanReads(infile, outfile):
    ''' Calculate the mean reads per cell '''

    t = T.setup(infile, outfile, PARAMS,
                memory=PARAMS["emptydrops_memory"], 
                cpu=PARAMS["emptydrops_slots"])

    options = {}
    options["outdir"] = t.outdir
    options["cellrangerDir"] = os.path.dirname(infile)

    task_yaml_file = os.path.abspath(os.path.join(t.outdir, 
                                                  "calculate_mean_reads.yml"))
    with open(task_yaml_file, 'w') as yaml_file:
        yaml.dump(options, yaml_file)

    log_file = t.log_file

    statement = '''Rscript %(cellhub_code_dir)s/R/scripts/emptydrops_calculate_mean_reads.R
                   --task_yml=%(task_yaml_file)s
                   --log_filename=%(log_file)s
                '''

    P.run(statement, **t.resources)

    IOTools.touch_file(outfile)


# ----------------------- Full Target and Main Function ---------------------- #

@follows(emptyDrops, meanReads)
def full():
    '''
    Run the full pipeline.
    '''
    pass

def main(argv=None):
    if argv is None:
        argv = sys.argv
    P.main(argv)

if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
