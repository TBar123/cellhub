##############################################################################
#
#   Kennedy Institute of Rheumatology
#
#   $Id$
#
#   Copyright (C) 2020 Stephen Sansom
#
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU General Public License
#   as published by the Free Software Foundation; either version 2
#   of the License, or (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
###############################################################################

"""===========================
Pipeline Emptydrops
===========================

:Author: Kathrin Jansen
:Release: $Id$
:Date: |today|
:Tags: Python

Overview
========

This pipeline performs the following task:

* run emptydrops on the raw output of cellranger

Usage
=====

See :ref:`PipelineSettingUp` and :ref:`PipelineRunning` on general
information how to use CGAT pipelines.

Configuration
------------

The pipeline requires a configured :file:`pipeline.yml` file.

Default configuration files can be generated by executing:

   python <srcdir>/pipeline_emptydrops.py config


Input files
-----------

The pipeline is run from the cellranger count output (raw_feature_bc_matrix folder).

The pipeline expects a tsv file containing a column named path and a column named
sample_id.

'path' should contain the path to each cellranger outs folder and the pipeline
will automatically add the path to raw_feature_bc_matrix.
'sample_id' is the desired name for each sample (output folder will be named like this).


Dependencies
------------

This pipeline requires:
* cgat-core: https://github.com/cgat-developers/cgat-core
* R + packages

Pipeline output
===============

The pipeline returns:
A list of barcodes passing emptydrops cell identification and a table with
barcode ranks including all barcodes (this can be used for knee plots).


Code
====

"""
from ruffus import *
from pathlib import Path
import sys
import os
import yaml
import cgatcore.experiment as E
from cgatcore import pipeline as P
import cgatcore.iotools as IOTools
import pandas as pd

# -------------------------- < parse parameters > --------------------------- #

# load options from the config file
PARAMS = P.get_parameters(
    ["%s/pipeline.yml" % os.path.splitext(__file__)[0],
     "../pipeline.yml",
     "pipeline.yml"])

# set the location of the tenx code directory
if "code_dir" not in PARAMS.keys():
    PARAMS["code_dir"] = Path(__file__).parents[1]
else:
    raise ValueError("Could not set the location of the code directory")


# ----------------------- < pipeline configuration > ------------------------ #

# handle pipeline configuration
if len(sys.argv) > 1:
        if(sys.argv[1] == "config") and __name__ == "__main__":
                    sys.exit(P.main(sys.argv))


# ########################################################################### #
# ######## Check input samples file and that the input exists ############### #
# ########################################################################### #


@originate("input.check.sentinel")
def checkInputs(outfile):
    '''Check that input_samples.tsv exists and the path given in the file
       is a valid directorys. '''

    if not os.path.exists("input_samples.tsv"):
        raise ValueError('File specifying the input samples is not present.'
                         'The file needs to be named "input_samples.tsv" ')

    samples = pd.read_csv("input_samples.tsv", sep='\t')
    for p in samples["path"]:
        print(p)
        if not os.path.exists(p):
            raise ValueError('Input folder from cellranger run (outs/)'
                             ' does not exist.')
    IOTools.touch_file(outfile)


def genClusterJobs():
    ''' Generate cluster jobs for each sample '''
    samples = pd.read_csv("input_samples.tsv", sep='\t')
    infile = None
    samples.set_index("sample_id", inplace=True)

    for sample_name in samples.index:
        sample_dir = sample_name + ".sample.dir"
        out_sentinel = os.path.join(sample_dir, "emptyDrops.sentinel")
        yield(infile, out_sentinel)


# ########################################################################### #
# ########################## Run EmptyDrops ################################# #
# ########################################################################### #

@follows(checkInputs)
@files(genClusterJobs)
def runEmptyDrops(infile, outfile):
    ''' Run Rscript to run EmptyDrops on each sample '''

    outdir = os.path.dirname(outfile)
    if not os.path.exists(outdir):
        os.makedirs(outdir)

    options = {}
    options["FDR"] = float(PARAMS["emptydrops_FDR"])

    sample_name = outfile.split("/")[0][:-len(".sample.dir")]
    options["outdir"] = outdir

    samples = pd.read_csv("input_samples.tsv", sep='\t')
    samples.set_index("sample_id", inplace=True)
    options["cellrangerDir"] = os.path.join(samples.loc[sample_name ,"path"],
                                            "raw_feature_bc_matrix")

    # # remove blacklisted cells if required
    # if 'blacklist' in samples.columns:
    #     options["blacklist"] = samples.loc[sample_name, "blacklist"]

    log_file = outfile.replace("sentinel","log")
    job_threads = PARAMS["emptydrops_slots"]
    if ("G" in PARAMS["emptydrops_memory"] or
    "M" in PARAMS["emptydrops_memory"] ):
        job_memory = PARAMS["emptydrops_memory"]

    task_yaml_file = os.path.abspath(os.path.join(outdir, "emptydrops.yml"))
    with open(task_yaml_file, 'w') as yaml_file:
        yaml.dump(options, yaml_file)

    statement = '''Rscript %(code_dir)s/R/run_emptydrops.R
                   --task_yml=%(task_yaml_file)s
                   --log_filename=%(log_file)s
                '''

    P.run(statement)

    IOTools.touch_file(outfile)

def genClusterJobsMeans():
    ''' Generate cluster jobs for each sample '''
    samples = pd.read_csv("input_samples.tsv", sep='\t')
    infile = None
    samples.set_index("sample_id", inplace=True)

    for sample_name in samples.index:
        sample_dir = sample_name + ".sample.dir"
        out_sentinel = os.path.join(sample_dir, "meanReads.sentinel")
        yield(infile, out_sentinel)

@follows(checkInputs)
@files(genClusterJobsMeans)
def calculateMeanReadsPerCell(infile, outfile):
    ''' Calculate the mean reads per cell '''

    outdir = os.path.dirname(outfile)
    if not os.path.exists(outdir):
        os.makedirs(outdir)

    options = {}
    sample_name = outfile.split("/")[0][:-len(".sample.dir")]
    options["outdir"] = outdir

    samples = pd.read_csv("input_samples.tsv", sep='\t')
    samples.set_index("sample_id", inplace=True)
    options["cellrangerDir"] = os.path.join(samples.loc[sample_name ,"path"],
                                            "raw_feature_bc_matrix")

    log_file = outfile.replace("sentinel","log")
    job_threads = PARAMS["emptydrops_slots"]
    if ("G" in PARAMS["emptydrops_memory"] or
    "M" in PARAMS["emptydrops_memory"] ):
        job_memory = PARAMS["emptydrops_memory"]

    task_yaml_file = os.path.abspath(os.path.join(outdir, "calculate_mean_reads.yml"))
    with open(task_yaml_file, 'w') as yaml_file:
        yaml.dump(options, yaml_file)

    statement = '''Rscript %(code_dir)s/R/calculate_mean_reads.R
                   --task_yml=%(task_yaml_file)s
                   --log_filename=%(log_file)s
                '''

    P.run(statement)

    IOTools.touch_file(outfile)


# ---------------------------------------------------
# Generic pipeline tasks

@follows(runEmptyDrops, calculateMeanReadsPerCell)
def full():
    '''
    Run the full pipeline.
    '''
    pass


if __name__ == "__main__":
    sys.exit(P.main(sys.argv))
